# 项目概述

## 项目亮点

1. 得益于 asp.net core 的良好设计,全面采用依赖注入的方式管理各个对象的之间的依赖关系
2. 借鉴了 DDD 设计模式(领域驱动设计)中的仓储理念,在项目中加入了按表拆分的仓储模式
3. 统一采用面向接口风格，来确保行为统一
4. 强大的条件查询,同时支持对象形式和字符串形式的查询条件,从而方便前端实现高级查询
5. 接入了 IdentityServer4,以便实现单点登录
6. 完整的单元测试,方便后期实现 DevOps CI\CD(持续集成\持续部署)

## 设计理念

1. 将业务层与数据层分离,让业务层没有数据库的概念.
2. 仓储层直接对接数据库,实现一系列具有原子性的数据库访问代码.例如:查询产品库存量,查询已销售数量,查询已开单数量,审核时修改标志,审核人,审核时间等等,具有不可拆分的逻辑.
3. 业务层(Service)负责组合调用仓储层的原子行为,来描述整体的业务逻辑.这就使得业务层不需要关心数据库的具体实现,仅描述一系列的原子行为即可组成一个完整的业务处理流程.去掉业务层数据库的概念,降低业务逻辑难度.
4. 全面使用依赖注入(DI)来降低对象与对象之间的耦合度.
5. 每编写一个 Service 和 Controller 都应该有对应的测试类,如果有必要,Common 层也可以写测试.(为了实现 DevOps CI\CD)
6. Service 应该遵循先定义行为(接口),描述一定要清晰,要具体到某一个行为. Controller 层应该直接依赖于 Service 层的行为,而不是实现类.
7. 一个仓储可以调用另一个仓储。同时应该避免仓储的相互依赖，如果出现了相互依赖(循环依赖)的情况，不适用构造函数注入，而是使用属性方式进行注入.([如何解决循环依赖](docs/循环依赖))
8. 一个服务也可以调用另一个服务。循环依赖问题的解决方案和仓储一样.

## 实现目标

1. 完善 README.md,详细说明项目结构和使用方法.需要给出完整的开发步骤,以及 common 层每个类的作用
2. 完善日志系统.控制台日志,文件日志,数据库日志
3. 完善模型验证(使用 asp.net core 自带的模型验证) --完成
4. 完善 API 返回内容的统一 --完成
5. 简化 common 层的内容,有些不常用的库用到的时候再加上
6. 完善 swgger 的实体文档描述 --完成
7. 完善 AOP 面向切面编程内容 --完成
8. 完善权限验证,包括数据库的表
9. 完善 EFCore 的配置.(尽量使用代码优先的方式) --完成
10. 添加单元测试,集成测试.(包含 web,service,common) --完成
11. 写个迁移工具,将 wcf 的 service 层解析为.net core 中的 controller
12. 搭建 identityserver4,并完善 ui.并且由它统一签发 Token --ui 未完成
13. 实现前端传入条件 object 到 LambdaExpress 的转换 --完成
14. 规范和实现前端传入数据的签名及验证
15. 将 zxsc 所有实体迁移到项目中(有点费脑筋，估计得写工具)

## 实现计划

?> 以下计划中只考虑迁移工作(包括账套的创建 API),不进行详细的重构

1. 将 WCF 中所有数据实体迁移到 Core 中
2. 将 WCF 中的 Service 迁移到 Controller 中
3. 将 WCF 中的 BLL 迁移到 Service 中
4. 完善 dotnet-zxtool 工具

?> 实现字符串条件的查询能力**原先的动态查询太臃肿,反正我没有找到详细的文档,不能完全掌控,就感觉不安全**  
大概实现思路如下:

1. 词法分析,将字符串条件拆成单词集合
2. 语法分析,将单词集合解析为语法树
3. 将语法树解析为 Lambda 表达式树，然后传递给 IQueryable 进行查询

?> 水晶报表貌似不支持 core 版的,得换成锐浪报表

1. 确认水晶报表和锐浪报表在 core 中是否可用
2. 如果可用则开始报表迁移,如果不可用则寻找替代方案

## 代码重构

1. 遵循面向对象的七大原则
2. 依赖注入尽量使用接口,用接口描述业务流程,而不是直接依赖于实现类
3. 关于是否接入 IdentityService4 进行讨论

## 项目部署

1. API 部署环境(本地开发时环境,测试环境,前端开发时环境,生产环境)
2. 数据库的部署
3. IdentityService4 的部署(如果启用)

?> PS: 如果只是为了实现分布式,不用 IdentityService4 ,仅靠 jwt 就能实现.  
IdentityService4 的优势在于能够统一管理用户,并且支持单点登录,在存在多个子系统的架构中使用比较友好.而在单系统中使用反而显得不够简洁.  
例如:我们的 zxsc 就算一个单系统,如果后期再有新的项目,就可以考虑将用户的信息统一在 sso 中管理,并且提供认证和授权的能力.
